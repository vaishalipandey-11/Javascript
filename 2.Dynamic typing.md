üß† What is "Dynamically Typed" in JavaScript?
In dynamically typed languages like JavaScript:
üìå You don‚Äôt need to tell the computer what type of value a variable will hold.
The type is decided automatically when the code runs.

let x = 5;        // JavaScript sees x as a number
x = "hello";      // Now x becomes a string
x = true;         // Now it's a boolean


üîπ 2. Reference Types in JavaScript
üìå Reference types are stored as memory addresses (references), not as actual values.
JavaScript has two broad value categories:
| Category            | Example Types                                                          |
| ------------------- | ---------------------------------------------------------------------- |
| **Primitive Types** | `String`, `Number`, `Boolean`, `null`, `undefined`, `Symbol`, `BigInt` |
| **Reference Types** | `Object`, `Array`, `Function`, `Date`, etc.                            |

| Type                         | Example                 |
| ---------------------------- | ----------------------- |
| Object                       | `{ name: "vp" }`        |
| Array                        | `[1, 2, 3]`             |
| Function                     | `function greet() {}`   |
| Date, RegExp, Map, Set, etc. | All are reference types |


‚úÖ Characteristics of Reference Types:
| Feature    | Description                                                           |
| ---------- | --------------------------------------------------------------------- |
| Stored in  | **Heap memory** (value is a reference/pointer)                        |
| Copied by  | **Reference**, not value                                              |
| Mutability | ‚úÖ Mutable (changing one reference affects others)                     |
| Comparison | Compared by **reference** (memory address), not by structure or value |

üì¶ Primitive vs Reference Types ‚Äì Comparison
| Feature    | Primitive Type                | Reference Type                      |
| ---------- | ----------------------------- | ----------------------------------- |
| Memory     | Stored in stack               | Stored in heap (reference in stack) |
| Assignment | Copied by value               | Copied by reference                 |
| Mutability | ‚ùå Immutable (mostly)          | ‚úÖ Mutable                           |
| Comparison | By value                      | By reference                        |
| Examples   | `42`, `"abc"`, `true`, `null` | `{}`, `[]`, `function(){}`          |


üìå What Is a Copy in JS?
When you copy an object or array, you can either:
| Type             | What it Means                                                                      |
| ---------------- | ---------------------------------------------------------------------------------- |
| **Shallow Copy** | Copies **only the first level**. Nested objects are still shared.                  |
| **Deep Copy**    | Copies **everything**, including nested objects/arrays. New memory for all levels. |

üîç Shallow Copy ‚Äì Simple but Dangerous
const original = {
  name: "vp",
  address: { city: "Delhi" }
};

const shallow = { ...original }; // OR Object.assign({}, original)
shallow.address.city = "Mumbai";

console.log(original.address.city); // "Mumbai" ‚ùó changed original too!
üß† Because only the top-level is copied, nested structures are still shared.

| Method                    | Use For | Limitations             |
| ------------------------- | ------- | ----------------------- |
| `Object.assign({}, obj)`  | Objects | Only top-level copy     |
| `{ ...obj }` (spread)     | Objects | Shallow copy only       |
| `[...arr]`                | Arrays  | Only first-level copied |
| `Array.prototype.slice()` | Arrays  | Same as spread          |
| `Array.from(arr)`         | Arrays  | Same                    |
| `.concat()`               | Arrays  | Shallow                 |

üîç Deep Copy ‚Äì Full Clone
const original = {
  name: "vp",
  address: { city: "Delhi" }
};

const deep = JSON.parse(JSON.stringify(original));
deep.address.city = "Mumbai";

console.log(original.address.city); // "Delhi" ‚úÖ not affected
Deep copy creates completely independent objects, even for nested ones.
| Method                                     | Pros                                   | Cons                                                            |
| ------------------------------------------ | -------------------------------------- | --------------------------------------------------------------- |
| `JSON.parse(JSON.stringify(obj))`          | Easy, native                           | ‚ùå Doesn‚Äôt support `undefined`, `function`, `Date`, `Map`, `Set` |
| `structuredClone(obj)` (‚úÖ modern browsers) | Deep clone everything except functions | ‚ùå Not supported in older browsers                               |
| `lodash.cloneDeep(obj)`                    | ‚úÖ Most reliable                        | Requires installing lodash                                      |
| Custom recursive function                  | Full control                           | Complex to write manually                                       |


üñºÔ∏è Visual: Shallow vs Deep Copy
Shallow Copy
original ‚Üí { a: 1, b: { c: 2 } }
                     ‚Üë
                   shared
                     ‚Üì
  copy    ‚Üí { a: 1, b: { c: 2 } }

  Deep Copy
  original ‚Üí { a: 1, b: { c: 2 } }

copy     ‚Üí { a: 1, b: { c: 2 } } // separate copy of `b`

| Feature            | Shallow Copy                 | Deep Copy                        |
| ------------------ | ---------------------------- | -------------------------------- |
| Copy Level         | Top-level only               | All levels (nested too)          |
| Shared references? | ‚úÖ Yes                        | ‚ùå No                             |
| Performance        | ‚úÖ Fast                       | üê¢ Slower                        |
| Use When?          | You don‚Äôt mutate nested data | You want a full independent copy |


